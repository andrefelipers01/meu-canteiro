<!-- ... Seu HTML idêntico ao anterior, acrescente só o botão abaixo se quiser: -->
<button id="downloadBtn" style="margin-top:10px;">Baixar como PNG</button>

<script>
/* ... Demais variáveis e funções ... */

// Novos campos em cada área: x, y (em metros)
function autoLayoutAreas(){
    // Refaz a organização das áreas (exceto a selecionada, se estiver moveando)
    let xAtual = 0, yAtual = 0, maxH = 0, spacing=0.03;
    areas.forEach(a => {
        if(a._locked) return; // NÃO reposiciona a que está sendo moveada!
        if(xAtual + a.width + spacing > siteWidth + 1e-5){
            xAtual = 0; yAtual += maxH + spacing; maxH = 0;
        }
        a.x = xAtual;
        a.y = yAtual;
        maxH = Math.max(maxH, a.length);
        xAtual += a.width + spacing;
    });
}

// --- Novíssimo desenho: posiciona cada área conforme x,y
function drawPlant(selectedArea = null){
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.save();
    ctx.scale(zoom, zoom);
    const padding = 28;
    const usableWidth = (canvas.width - 2*padding) / zoom;
    const usableHeight = (canvas.height - 2*padding) / zoom;
    const pxPerM_W = usableWidth / siteWidth;
    const pxPerM_L = usableHeight / siteLength;

    // Limite do canteiro
    ctx.strokeStyle = '#2b4162';
    ctx.setLineDash([]);
    ctx.lineWidth = 4;
    ctx.strokeRect(padding, padding, pxPerM_W * siteWidth, pxPerM_L * siteLength);

    // Ambientes
    let colorStep = 360/(areas.length+1);
    areas.forEach((area, i) => {
        let drawX = padding + (area.x??0)*pxPerM_W;
        let drawY = padding + (area.y??0)*pxPerM_L;
        let areaPxW = area.width*pxPerM_W;
        let areaPxL = area.length*pxPerM_L;

        ctx.fillStyle = `hsl(${(i*colorStep+47)%360},72%,84%)`;
        ctx.strokeStyle = (area === selectedArea) ? "#d35400" : "#2b4162";
        ctx.lineWidth = (area === selectedArea) ? 4 : 2;
        ctx.setLineDash([7,5]);
        ctx.beginPath();
        ctx.rect(drawX, drawY, areaPxW, areaPxL);
        ctx.fill();
        ctx.stroke();

        ctx.setLineDash([]);
        ctx.fillStyle = "#2b4162";
        ctx.font = 'bold 15px Arial';
        ctx.fillText(area.name, drawX+7, drawY+19);
        ctx.font = 'normal 13px Arial';
        ctx.fillText(`${area.width.toFixed(1)} x ${area.length.toFixed(1)} m`, drawX+7, drawY+36);
        ctx.fillText(`(${area.size.toFixed(2)} m²)`, drawX+7, drawY+54);
    });

    // Grade múltiplos 0,6m
    ctx.save();
    ctx.strokeStyle = "#aac";
    ctx.lineWidth = 1;
    ctx.setLineDash([2,6]);
    for(let x=0.6; x<siteWidth;x+=0.6){
        ctx.beginPath();
        ctx.moveTo(padding + x*pxPerM_W, padding);
        ctx.lineTo(padding + x*pxPerM_W, padding+pxPerM_L*siteLength);
        ctx.stroke();
    }
    for(let y=0.6; y<siteLength;y+=0.6){
        ctx.beginPath();
        ctx.moveTo(padding, padding + y*pxPerM_L);
        ctx.lineTo(padding+pxPerM_W*siteWidth, padding + y*pxPerM_L);
        ctx.stroke();
    }
    ctx.restore();

    ctx.fillStyle = "#555";
    ctx.font = "12px Arial";
    ctx.fillText(siteWidth + " m", padding + pxPerM_W * siteWidth / 2 - 19, padding - 8);
    ctx.save();
    ctx.translate(padding - 15, padding + pxPerM_L*siteLength/2 + 19);
    ctx.rotate(-Math.PI/2);
    ctx.fillText(siteLength + " m", 0,0);
    ctx.restore();
    ctx.restore();
}

// --- Drag'n'drop ---
let dragArea = null;
let dragOffsetX = 0, dragOffsetY = 0;

// Traduz coordenada pixel do mouse para metro "relativo ao canto da área"
function getAreaUnderCursor(mx, my){
    const padding = 28;
    const usableWidth = (canvas.width - 2*padding) / zoom;
    const usableHeight = (canvas.height - 2*padding) / zoom;
    const pxPerM_W = usableWidth / siteWidth;
    const pxPerM_L = usableHeight / siteLength;
    let x = (mx/zoom - padding) / pxPerM_W;
    let y = (my/zoom - padding) / pxPerM_L;
    // Percorrer do último para o primeiro (top to bottom)
    for(let i=areas.length-1;i>=0;i--){
        let a = areas[i];
        if(x >= a.x && x <= a.x+a.width && y >= a.y && y <= a.y+a.length){
            return a;
        }
    }
    return null;
}

canvas.addEventListener('mousedown', function(e){
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left);
    const my = (e.clientY - rect.top);
    let a = getAreaUnderCursor(mx, my);
    if(a){
        dragArea = a;
        dragArea._locked = true;
        // Offset para o arrasto não “pular”
        const padding = 28;
        const usableWidth = (canvas.width - 2*padding) / zoom;
        const usableHeight = (canvas.height - 2*padding) / zoom;
        const pxPerM_W = usableWidth / siteWidth;
        const pxPerM_L = usableHeight / siteLength;
        dragOffsetX = ((mx/zoom - padding) / pxPerM_W) - a.x;
        dragOffsetY = ((my/zoom - padding) / pxPerM_L) - a.y;
    }
    drawPlant(dragArea);
});

canvas.addEventListener('mousemove', function(e){
    if(!dragArea) return;
    const rect = canvas.getBoundingClientRect();
    const mx = (e.clientX - rect.left);
    const my = (e.clientY - rect.top);
    const padding = 28;
    const usableWidth = (canvas.width - 2*padding) / zoom;
    const usableHeight = (canvas.height - 2*padding) / zoom;
    const pxPerM_W = usableWidth / siteWidth;
    const pxPerM_L = usableHeight / siteLength;
    let nx = ((mx/zoom-padding)/pxPerM_W) - dragOffsetX;
    let ny = ((my/zoom-padding)/pxPerM_L) - dragOffsetY;
    // Snap pra múltiplos de 0,6m!
    nx = Math.max(0, Math.round(nx/0.6)*0.6);
    ny = Math.max(0, Math.round(ny/0.6)*0.6);
    // Bloqueios dentro do canteiro:
    if(nx+dragArea.width > siteWidth) nx = siteWidth-dragArea.width;
    if(ny+dragArea.length > siteLength) ny = siteLength-dragArea.length;
    dragArea.x = nx;
    dragArea.y = ny;
    drawPlant(dragArea);
});

canvas.addEventListener('mouseup', function(e){
    if(!dragArea) return;
    // Ao soltar, verificar se há superposição:
    let colidiu = false;
    areas.forEach(a=>{
        if(a===dragArea) return;
        // Checa bounding box
        if(!(dragArea.x+dragArea.width <= a.x
            || dragArea.x >= a.x+a.width
            || dragArea.y+dragArea.length <= a.y
            || dragArea.y >= a.y+a.length)){
            colidiu = true;
        }
    });
    if(colidiu){
        // Reverte à posição de menor sobreposição:
        autoLayoutAreas();
        alert("Sobreposição detectada! Área retornou ao layout automático.");
    }else{
        // Move selecionada, re-layouteia o resto:
        // Reposiciona áreas não moveadas:
        let salvoArea = dragArea; 
        areas.forEach(a=>{ delete a._locked; });
        let outOfLayout = areas.filter(a=>a!==salvoArea);
        // layout só dos outros
        let x=0,y=0,maxH=0, spacing=0.03;
        outOfLayout.forEach(a=>{
            // Ignora posição se ele colidir com a área moveada
            if(
                !(x+a.width <= salvoArea.x
                  || x >= salvoArea.x+salvoArea.width
                  || y+a.length <= salvoArea.y
                  || y >= salvoArea.y+salvoArea.length)
            ){
                // Pula linha se colidir
                x=0; y+=maxH+spacing; maxH=0;
            }
            if(a._locked) return;
            a.x = x; a.y = y;
            maxH = Math.max(maxH, a.length);
            x += a.width+spacing;
        });
    }
    dragArea = null;
    drawPlant();
});
canvas.addEventListener('mouseleave', function(e){
    // Solta o drag
    dragArea = null;
    areas.forEach(a=>{ delete a._locked; });
    drawPlant();
});

// --- Botão baixar como png
document.getElementById('downloadBtn').addEventListener('click', function(){
    let dataUrl = canvas.toDataURL("image/png");
    let link = document.createElement('a');
    link.download = "planta_canteiro.png";
    link.href = dataUrl;
    link.click();
});

// --- Adicione essas linhas na inserção das áreas para layoutar tudo:
function layoutInit() {
    autoLayoutAreas();
    drawPlant();
}
siteForm.addEventListener('submit', function(e){ /* ... */ layoutInit(); });
areaForm.addEventListener('submit', function(e){ /* ... */ layoutInit(); });
// E após remover uma área: layoutInit();

/* ... O restante igual ao seu código anterior ... */
</script>
